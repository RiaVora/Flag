# Flag
PURPOSE: The purpose of the flag project is to create an American flag according to the specification file provided by the US Flag Spec source listed below, with the precise measurements, correct blue and red colors (based on RGB), and the ability to scale based on the changing of window size. The code I created fulfills these specifications to the best of my ability, but still stands for improvement. There are still two main issues that stand out, partially based on the ambiguity in the stated instructions; the exactness of the stars and the method I used to scale the flag. For the organization of my flag, as explained in the pre-plan, I broke my flag into four parts: the blue union, the stars, the stripes & background, and the organization & scaling. Lastly, I faced many challenges throughout completing the flag project, specifically with the creation of the perfect star and the scaling of the flag, but was able to overcome them with help from friends, Kuszmaul, Tutorial Point, and Stack Overflow. Through these challenges, the plan, analysis, and errors, I have been able to create an American flag following the details in the instructional file.

FULLFILLMENT OF SPECIFICATION: My java code successfully fulfills the requirements from the specification file (picture shown to the left) with exact measurements, the correct blue and red colors, 50 white symmetrical stars, correctly coordinated over the blue union, and scaling through window size. After some experimentation, I chose a scale factor of 400x to reach both an easy and aesthetically pleasing representation of the flag. Therefore, every measurement for the flag is exactly 400x the measurement listed on the picture on the left. However, since these numbers had to be integers, and some of the numbers with 400 scaling ended up being decimals, the measurements entered in as the size of each shape are rounded either by hand or through java by forcing doubles to become integers. Next, for the colors, I used Google to search up the RGB values for the three real colors of the American Flag , and then inputted them using the color method. Lastly, the white stars are placed using exactly the G/H and E/F x 400, and with the radius of the given K/2 x 400 (since the diameter was given and not the radius). Finally, the last requirement was a flag that scaled. This was done by averaging the ratio of the current height/preset height and the ratio of the current width/preset width. This way, by moving singularily width or singularly height, the flag still scales.

ERROR EXPLANATION: My American flag meets all of the expectations detailed in the project, but still falls short because of a few issues that aren’t a perfect representation of the flag and the scaling. First, the stars are estimated values to create a good-looking star, but not a perfect one. I created a star at (100, 100) and with a radius of around 23, and made a nice star, but not exact. For each x and y coordinate of the star, I then subtracted 100 to get the star’s coordinates when the center was at (0, 0), and then divided the coordinates by 23 to get them at a radius of 1. These were the base points used for every star. However, if I used trigonometry, I would’ve gotten exact points for each coordinate of the star, and my base points would be more accurate, and each star would be perfect. Instead, I used my eyes and created a star with approximate coordinates, and adding trigonometry is one part that I would definitely fix. Next, the scaling is another component that can be improved. In order to scale precisely, I used the ratio of current height/preset height and the ratio of the current width/preset width. I took the average of both of these, and used this as my one universal scale factor. Therefore, if you move only the width, the flag scales, and if you move only the height, then the star scales as well. Before, we used only the height to scale the flag, so changing the width had no effect on it, which wasn’t a real scaling to the window width. Now, the averaging allowed for perfect scaling when changing both the width and the height. This provided a fix to the height only problem, but presented another. When changing just the width, for example, one can pull the width over the flag, and cut it off. The flag does not scale enough to be prevented from being cut off the screen, so this is a problem presented. Otherwise an average can also be considered to be inaccurate by others of the window screen, but it is a better alternative to just the height, and aesthetically looks like it meets every condition. For this error, I would find a better way to judge scaling instead of averaging, and more importantly find a way to prevent the flag from running off of the screen with a few extra methods. Overall, the two major parts of the flag code I would improve is the exactness of the star and the method I used for scaling.

OVERVIEW: First, the code creates four private variables, two being int arrays x1 and y1 for the stars that are customized later, and two being double arrays xg and yg for the base star coordinates at (0, 0) and radius 1. The class Flag extends from JFrame, and I import the necessary JFrame components. When an instance of Flag is created, in main, the init() method is run. The init method set the size for the window (900, 600) and runs the repaint() method, which runs through paint() continuously. Next, I redefine the method paint() to create the flag. First, I run super.paint() to delete all of the past graphics every time, so the scaling works. Then, I create the scaling variables I explained above, with the average of the ratios of the height and width. After that, I made the red background, setting the color and the right coordinates, and multiplying everything by the scale factor created above. After that, the white rectangles are created, using a for loop with a separation of 62 pixels on the y axis in between, with the preset 400x coordinates, and all multiplied by the scale factor. This part is also to a perfect white, with an RGB of (255, 255, 255), as detailed by the specifications. Next, the blue union was conducted fairly similarly to the red rectangle, with a different color but with present conditions multiplied by the scale factor and the 400x factor, and inserted into the fillPolygon() method. Finally, the creation of the stars. The stars have the same set color as the rectangles, and then the radius is created, with the preset number based on 400x and multiplied by the scale factor. The rest of the variables are all multiplied by the scale factor. Next, using the coordinates of the union as a guide, we add a scaled number to that for the y and the x to get the correct position of the first star. The next two variables are the movement of x and y across the rows of stars, in between each one, multiplied by the scale factor. Lastly, there is the loop of creating the stars. First, the i runs through six times to make the rows of six stars, and then the sixth star in the row is excluded for all of the odd j values (four times) to make the rows of five stars. So, with the total of 9 j’s, when j is even (five times) the stars of six rows are created, and the i and j are used to decide the coordinates for each star accordingly. And, outside of the paint method, the stars method. The xg and yg arrays from the beginning stand as a double arrays so the fractions can be correctly accounted for. The stars() method takes a radius and multiplies the xg and yg points by it to get the correct size of the star, and then takes the x and y coordinates (a total of three arguments) of the center of the star and adds it to the results of xg and yg. The method multiplies and adds to the xg and yg base star arrays, but stores the changes in the x1 and y1 arrays, which are preset to 10 1’s each. Since the x1 and y1 are int arrays, and the Polygon method takes int arrays, I forced the changes for xg and yg to be integers in the stars() method. This is the basic structure of my star code, and how it creates each aspect of the flag.

MAJOR CHALLENGES: There were two major challenges I faced in the code, the creation of the stars and the scaling of the flag. With the creation of the stars, I could not figure out how to make the perfect star without trigonometry, which greatly frustrated me. I tried everything from perfect right triangles to pentagons, and I still wasn’t able to make one. I worked with my friends before to create a star with a radius of 23 that wasn’t perfect but looked ok, so I found out that was the best I could do. However, past that point, I was still stuck on how to change each of the coordinates and make it scalable. So then, I sat down with Kuszmaul, and he talked me through each part of creating a scaleable stars method. It took nearly the entire class period, but I was able to create different arrays (the xg, yg, x1, and y1), the method, and finally understand their use. This was a large struggle for me, and figuring it out with a teacher was gratifying. The second struggle I had was with the scaling. Creating each variable separately to add a multiplication by the scale factor was annoying, but tolerable. Then, finding the scale factor proved not to be that difficult either. However, the hard part struck when the scaling worked, but the previous flags showed up as well as the new one. So, my friend and I went to the internet to look up any idea on how to delete past graphics, especially in the init() or paint() given JFrame methods. We spent nearly an hour looking through many different websites, trying so many different ideas, and searching up countless keywords, and we still came up empty-handed. Nothing was working. Then, finally, we found one piece of code on a Stack Overflow website on a different but similar topic, and desperately tried it. It was calling super.paint() in the paint() method, and it worked! This was a large success for me, after spending the whole day finished the scale factor, to finally see it all come to place. But then, we were met with another error. The background disappeared, and was replaced with a light gray. We tried putting the background in every single method in the flag class, and it proved not to work. Frustrated, my friend and I went back to the internet again to look up a way for the background to be initialized. After looking through more websites for another half an hour, we thought about initializing the background in main. After searching this up, we found some code that allowed a background in the main! We implemented it, and it worked. Finally, the night of work was done, and it was a great relief. Overall, these were my worst struggles, and I’m glad I overcame them.

ACKNOWLEDGEMENTS: Thank you to http://www.usflag.org/flag.specs.html, which provided us with the exact dimensions and colors of the American flag. Additionally, I would like to thank all of my friends for helping me struggle through each one of my areas of improvement and challenges, Kuszmaul for pushing me through the star creation code, and Tutorial Point, and Stack Overflow for providing me with sufficient java information to troubleshoot through difficult areas.
